<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
[Назад](README.md)<br />**Содержание**

- [Управляемые и неуправляемые компоненты](#%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B8-%D0%BD%D0%B5%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B)
  - [Определение](#%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)
  - [Пример](#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
  - [В коде](#%D0%B2-%D0%BA%D0%BE%D0%B4%D0%B5)
  - [Плюсы и минусы](#%D0%BF%D0%BB%D1%8E%D1%81%D1%8B-%D0%B8-%D0%BC%D0%B8%D0%BD%D1%83%D1%81%D1%8B)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Управляемые и неуправляемые компоненты

## Определение

Концепция разделения компонентов на **управляемые и неуправляемые** позволяет более явно определять место хранения логики компонентов и то, как с ними можно будет работать. 

* Компонент считается управляемым, если на его состояние влияет только компонент-родитель, а сам управляемый компонент занимается только отображением данных и отправкой событий "наверх"
* Неуправляемые компоненты не дают возможности влиять на их состояние. Они сами обрабатывают состояние. Хотя они и могут отправлять события родителю, это не будет влиять на них. 

## Пример

**Примером может быть абстрактный компонент `Input`.**

В случае, если мы сделаем его контролируемым:

* У него не будет своего состояния
* Он будет принимать параметр `value`
* Компонент-родитель будет решать, как обрабатывать (и обрабатывать ли вообще) `onChange`

Если сделать его неконтролируемым:

* У `Input` будет состояние с данными, введенными в поле
* Он не будет принимать `value` от родителя, а будет хранить его сам
* Он сам будет обрабатывать `onChange`, менять свое состояние, и отправлять родителю результат
* Компонент-родитель не сможет влиять на его значение

## В коде

**Управляемый `Input`:**

```javascript
const Input = ({ value, onChange }) => {
    return <input
    	value={value}
    	onChange={(e) => {
            onChange(e.target.value);
    	}}
    />;
}
```

**Неуправляемый `Input`:**

```javascript
const Input = ({ onChange }) => {
    const [value, setValue] = useState('');
    return <input
    	value={value}
    	onChange={(e) => {
            setValue(e.target.value);
            onChange(e.target.value);
    	}}
    />;
}
```

## Плюсы и минусы

| Тип           | Плюсы                            | Минусы                                          |
| ------------- | -------------------------------- | ----------------------------------------------- |
| Управляемые   | - Можно поменять состояние извне | - Нужно писать дополнительную логику в родителе |
| Неуправляемые | - Вся логика внутри компонента   | - Нельзя повлиять извне                         |

