# Деструктуризация

## Определение

**Деструктуризация** –  это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.

## Массивы

### Синтаксис

```javascript
const/let/var [список] = массив;
```

* Где *список* это перечисленные через запятую идентификаторы новых переменных
  * Идентификатор может быть не указан
  * Идентификатор может иметь значение по умолчанию (`variableName="defaultValue"`)
    * Значением по умолчанию может быть любое допустимое (см [типы](types.md)) значение
    * Значением по умолчанию может быть вызов функции, тогда она будет вызвана только в случае, если понадобится значение по умолчанию
  * Можно использовать оператор [rest](spread_rest.md)

* А *массив* – переменная, в которой хранится массив или другое итерируемое (см [итераторы](iterators.md), [генераторы](generators.md)) значение или само это значение (например, `[1, 2]`)

> Например:
>
> ```javascript
> const [a, b, c] = arr;
> ```
>
> ```javascript
> const [a,  , c] = arr;
> ```
>
> ```javascript
> const [a, b="defaultValue", c=getDefaultValue()] = arr;
> ```
>
> В последнем примере `getDefaultValue` будет вызвана только в том случае, если значения для `c` в массиве не будет. 

### Принцип работы

Для примера:

```javascript
const [first,  ,  , fourth=getDefaultFourth()] = arr;
```

В переменные `first` и `fourth` запишутся соответственно *первый* и *четвертый* элементы массива, если они есть. Если значения для `fourth` нет, будет вызвана `getDefaultFourth` и в `fourth` запишется её результат. 

## Объекты

### Синтаксис

```javascript
const {
  список
} = объект;
```

* Где *список* это перечисленные через запятую идентификаторы новых переменных
* А объект – переменная, содержащая объект или сам объект (например, `{ a: 'a' }`)

#### Синтаксис элементов списка

```javascript
ключ:переменная=значение_по_умолчанию
```

* *ключ* – ключ свойства в объекте
* *:переменная* – указание на то, в какую переменную сохранить значение свойства. Если не указано, название будет совпадать с ключом
* *=значение_по_умолчанию* – значение по умолчанию, аналогично ситуации с массивами

Так запись может быть как такой:

```javascript
name
```

Так и такой:

```javascript
name:nameValue=getDefaultNameValue()
```

### Принцип работы

Для примера:

```javascript
const {
  name,
  lastName:ln,
  fullName:fn="default",
  age=0,
} = object;
```

* В переменную `name` запишется значение свойства `name` из `object`
* В переменную `ln` запишется значение свойства `lastName` из `object`
* В переменную `fn` запишется значение свойства `fullName` из `object`. Если его нет, запишется `"default"`
* В переменную `age` запишется значение свойства `age` из `object`. Если его нет, запишется `0`

## Вложенная деструктуризация

И для объектов, и для массивов, доступна вложенная деструктуризация.

### Массивы

```javascript
const [a, b, [ ca, cb ]] = arr;
```

Здесь создадутся переменные `a` и `b`, указывающие на первый и второй элементы `arr`. Затем из третьего значения, в котором содержится массив, будут созданы переменные `ca` и `cb`, поскольку "целью" для сохранения третьего значения было указано новое использование деструктуризации. 

### Объекты

```javascript
const {
  name,
  lastName,
  address: {
    home: {
      street,
      house,
    },
  },
} = object;
```

Так, создадутся новые переменные `name`, `lastName`, `street` и `house` с соответствующими структуре объекта значениями. Ключи `address` и `home` будут использованы для чтения, но не будут сохранены в переменные, так как "целью" для их сохранения (значением после двоеточия) будет новое использование деструктуризации. 

### Смешанные случаи

Поскольку в объектах и в массивах могут храниться любые значения, могут быть ситуации, когда в массиве, например, хранится объект, у которого в одном из свойств хранится массив. Для таких ситуаций тоже доступна деструктуризация:

```javascript
const arr = [
  {
    values: ["one", "two"],
  },
];
const [
  {
    values: [first, second],
  },
] = arr;
```

Переменные `first` и `second` получат значения `"one"` и `"two"`.