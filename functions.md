<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
[Назад](README.md)<br />**Содержание**

- [Функции](#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
  - [Определение](#%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)
  - [Структура](#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0)
  - [Принцип работы](#%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B)
    - [Объявление](#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)
    - [Вызов (использование) функции](#%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
    - [Возвращение значения из функции](#%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8%D0%B7-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
  - [Классификация](#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F)
  - [Различия видов функций](#%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D1%8F-%D0%B2%D0%B8%D0%B4%D0%BE%D0%B2-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9)
    - [Function Declaration (обычные функции)](#function-declaration-%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
    - [Function Expression](#function-expression)
    - [Стрелочные функции](#%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
  - [Дополнительно: IIFE](#%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE-iife)
  - [Связанные темы](#%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%82%D0%B5%D0%BC%D1%8B)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Функции

## Определение

**Функции** – фрагмент программы, который можно использовать из другой части программы. 

## Структура

Функция состоит из

* Названия (кроме анонимных функций)
* Списка аргументов
* Тела

> Например:
>
> ```javascript
> function getFullName(firstName, lastName) {
>   const fullName = firstName + ' ' + lastName;
>   return fullName;
> }
> ```
>
> Здесь объявлена функция `getFullName` с аргументами `firstName` и `lastName` и телом функции между `{` и `}`. 

## Принцип работы

### Объявление

На момент объявления функции движок не выполняет её код, а только создает её, сохраняя всю функцию для дальнейшего использования.

### Вызов (использование) функции

Для вызова функции используется её имя, после которого ставятся круглые скобки. В скобках через запятую перечисляются значения для аргументов функции. 

> Например, `getFullName('John', 'Doe')` вызовет функцию `getFullName` и "передаст" ей две строки –  `'John'` и `'Doe'`. 

Дальше выполнение кода переходит в тело функции, объявленной ранее. Там переданные значения будут доступны в переменных `firstName` и `lastName` (это переменные, *автоматически создаваемые для области видимости этой функции* при её объявлении, а при вызове в них записывается то, что было передано в функцию). 

Выполнение функции продолжается до тех пор, пока не будет достигнут конец её тела, либо пока не будет встречено ключевое слово `return` (см ниже). Дальше выполнение возвращается туда, откуда была вызвана функция. 

> Каждый вызов функции не связан с предыдущим. Можно вызывать функцию сколько угодно раз и передавать ей любые значения – каждый раз она будет выполняться заново. 

### Возвращение значения из функции

Поскольку переменные, создаваемые внутри функций, недоступны вне её (см [область видимости](scope.md)), для использования значений, вычисляемых функциями, требуется "вернуть" их вместе с завершением функции. Для этого используется ключевое слово `return`. 

Любое значение, находящееся после `return`, будет считаться результатом работы функции. Этот результат будет доступен там, откуда функция была вызвана:

```javascript
function getSomething() {
  // ...
  return 3;
}

const result = getSomething(); // result будет равен 3
```

Если функция закончится, а `return` не будет встречен, результатом работы функции будет `undefined` (см [типы](types.md)). 

## Классификация

* По типу объявления
  * Function Declaration (объявление функции)
  * Function Expression (функциональное выражение)
* По типу функции
  * Обычные функции
  * Стрелочные функции
* По именованности
  * Именованные
  * Анонимные

## Различия видов функций

### Function Declaration (обычные функции)

Такие функции объявляются следующим образом:

```javascript
function название_функции(аргумент1, аргумент2) {
  тело_функции
}
```

### Function Expression

```javascript
function (аргумент1, аргумент2) {
  тело_функции
}
```

> Примеры использования
>
> ```javascript
> var getSmth = function () {...}
> getSmth();
> ```
>
> ```javascript
> doSomething(function () {...})
> ```

Отличие функциональных выражений в том, что они не имеют имени (*анонимны*), если не записаны в переменную. Однако они могут быть записаны в переменные или переданы в качестве аргументов:

```javascript
const getSmth = function () {}
```

```javascript
showQuestion(function () {}); // так функциональное выражение попадет в первый аргумент функции showQuestion и сможет быть использовано внутри
```

### Стрелочные функции

```javascript
(аргумент1, аргумент2) => {
  тело_функции
  return результат (опционально)
}
```

Или, в простых случаях

```javascript
(аргумент1, аргумент2) => результат
```

Как и функциональные выражения, могут быть анонимными. Отличие от других типов в том, что стрелочные функции сохраняют [контекст](this.md), в котором были созданы, поменять его нельзя. В простых случаях можно опустить описание тела функции и сразу вернуть результат. 

> Например, `(a, b) => a + b`) эквивалентно такому коду:
>
> ```javascript
> (a, b) => {
>   return a + b;
> }
> ```

## Дополнительно: IIFE

*(Immediately invoked function expression, немедленно вызываемые функциональные выражения)*

Функциональные выражения и стрелочные функции можно вызвать сразу же после их описания:

```javascript
(function () {
  
})()
```

```javascript
(() => {
  
})()
```

Здесь выражение или стрелочная функция заключены в скобки, после которых мы сразу же их вызываем. Это используется для принудительного создания новой области видимости, чтобы не затрагивать глобальную область в процессе выполнения программы. Обычно в IIFE оборачивается весь код программы, которая потенциально может выполняться в одном окружении с другими программами (например, разные скрипты на одном сайте). 

## Связанные темы

* [Чистые функции](clean_functions.md)
* [Функции более высокого порядка](hof.md)
