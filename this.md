<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
[Назад](README.md)<br />**Содержание**

- [Контекст, `this`](#%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82-this)
  - [Определение](#%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)
  - [Правила привязки `this`](#%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B8-this)
    - [Привязка по умолчанию](#%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B0-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E)
    - [Неявная привязка](#%D0%BD%D0%B5%D1%8F%D0%B2%D0%BD%D0%B0%D1%8F-%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B0)
    - [Явная привязка](#%D1%8F%D0%B2%D0%BD%D0%B0%D1%8F-%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B0)
    - [Жесткая привязка](#%D0%B6%D0%B5%D1%81%D1%82%D0%BA%D0%B0%D1%8F-%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B0)
  - [Применение `this`](#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-this)
  - [Привязка для конструкторов](#%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B0-%D0%B4%D0%BB%D1%8F-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2)
  - [Лексический `this`](#%D0%BB%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-this)
  - [Задание](#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Контекст, `this`

## Определение

**`this`** – специальный идентификатор, создаваемый при вызове функции и указывающий на "владеющий" или "содержащий" объект. Также называют контекстом.

Внутри любой функции доступен `this`.

> В широком смысле контекст – это все обстоятельства вызова функции, но здесь идет речь только об определенной "привязке" к объекту. 

## Правила привязки `this`

Есть несколько вариантов привязки `this` (от самого низкоприоритетного к самому приоритетному):

1. Привязка по умолчанию
2. Неявная привязка
3. Явная привязка
4. Жесткая привязка

### Привязка по умолчанию

По умолчанию `this` в функции зависит от [строгого режима](strict_mode.md) (важно состояние строгого режима именно внутри функции):

* Если строгий режим включен, `this` будет `undefined`
* Если выключен, глобальный объект (`window` или `global`)

### Неявная привязка

Неявная привязка строго зависит от того, **как** вызывается функция:

- Если функция вызывается, считываясь из свойства объекта, `this` будет указывать на последний объект перед этой функцией.

  >  Например, для `obj.foo()` это будет `obj`, а для `user.location.street.update()` это будет `street`

- Если функция вызывается не "из" объекта (например, просто `foo()`), сработает правило по умолчанию

> Опять же, важна точка вызова:
>
> ```javascript
> let object = {
>   foo: function() {...}
> };
> object.foo(); // this === object
> let fn = object.foo;
> fn(); // this === по умолчанию
> ```
>
> То же самое произойдет при передаче функции как аргумента:
>
> ```javascript
> let object = {
>   foo: function() {...}
> };
> doSomething(object.foo); 
> ```
>
> Для привязки последняя строка не будет иметь значения, важно будет то, что происходит внутри функции `doSomething` и как вызывается функция там.

### Явная привязка

Для явной, принудительной привязки `this` к какому-то значению, используются два метода из [прототипа](prototype.md) функций: 

* `call` 
* `apply`

Оба метода первым аргументом получают объект, который будет привязан к `this` при текущем вызове функции:

```javascript
let object = {
  foo: function() {...}
};
let a = {};
object.foo.call(a); // this === a
object.foo.apply(a); // this === a
```

Разница `call` и `apply` в том, что `call` принимает остальными аргументами то, что будет передано аргументами в функцию, а `apply` принимает [массив](arrays.md) этих аргументов:

```javascript
let foo = function (a, b) {...};
foo.call(obj, 1, 2); // в foo попадут аргументы 1, 2
foo.apply(obj, [3, 4]); // в foo попадут аргументы 3, 4
```

### Жесткая привязка

Для жесткой привязки существует метод прототипа функций `bind`. Он создает и возвращает новую функцию с жестко привязанным `this` для всех вызовов.

```javascript
let obj = {};
let foo = function () {...};
let bindedFoo = foo.bind(obj);
bindedFoo(); // this === obj вне зависимости от условий
```

Как и `call`, остальными аргументами позволяет передать значения, которые будут передаваться в аргументы функции при каждом вызове:

```javascript
let foo = function (a, b, c) {...};
let bindedFoo = foo.bind(obj, 1, 2);
bindedFoo(3); // в foo попадут аргументы 1, 2, 3
```

## Применение `this`

Подробнее и более полезно в [прототипном наследовании](prototype.md).

Основная цель `this` – использование одной функции для разных объектов.
Например, мы хотим сделать функцию, которая сможет устанавливать значения свойств "содержащих" ее объектов:

```javascript
const setKeyValue = function (key, value) {
  this[key] = value;
};

const object1 = { setKeyValue };
const object2 = { setKeyValue };
const object3 = { setKeyValue };
```

Так для всех трех объектов будет доступна **одна и та же** функция, которая будет работать через `this` с тем объектом, через который мы ее вызовем:

```javascript
object1.setKeyValue('test', 1);
// object1 -> { setKeyValue: function, test: 1 }
```

## Привязка для конструкторов

При использовании [конструкторов](constructors.md) `this` автоматически привязывается к новому, создаваемому конструктором, объекту. 
Этот вид привязки самый приоритетный.

> Стрелочные функции не могут быть конструкторами 

## Лексический `this`

Для стрелочных функций **никакие** правила привязки `this` не применяются. Для них `this` лексический (работает по месту создания, как при поиске переменных), что означает, что он будет жестко закреплен за тем `this`, который был в его области видимости на момент создания функции:

```javascript
const foo = function () {
  const bar = () => {
    console.log(this);
  }
  return bar;
}
const a = { a: 'b' };
const bar = foo.call(a); // в foo this === a
bar.call({}); // выведет { a: 'b' }, так как в момент создания в foo this указывал на a
```

## Задание

Что будет в `answers`? Для простоты примем, что строгий режим выключен, а глобальный объект называется `window`.

```javascript
const a = {
  a: 'a'
};
const obj = {
  getThis: () => this,
  getThis2 () {
    return this;
  }
};
obj.getThis3 = obj.getThis.bind(obj);
obj.getThis4 = obj.getThis2.bind(obj);
const answers = [
  obj.getThis(),
  obj.getThis.call(a),
  obj.getThis2(),
  obj.getThis2.call(a),
  obj.getThis3(),
  obj.getThis3.call(a),
  obj.getThis4(),
  obj.getThis4.call(a)
];
```