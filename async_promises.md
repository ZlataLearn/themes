<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
[Назад](README.md)<br />**Содержание**

- [Промисы](#%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%D1%8B)
  - [Определение](#%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)
  - [Состояния](#%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F)
  - [Способ использования](#%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
  - [Создание промиса](#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%D0%B0)
  - [Добавление обработчиков](#%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%BE%D0%B2)
  - [Цепочки промисов](#%D1%86%D0%B5%D0%BF%D0%BE%D1%87%D0%BA%D0%B8-%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%D0%BE%D0%B2)
    - [Что можно вернуть из `then`](#%D1%87%D1%82%D0%BE-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%B2%D0%B5%D1%80%D0%BD%D1%83%D1%82%D1%8C-%D0%B8%D0%B7-then)
    - [Обработка ошибок в цепочке](#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D0%B2-%D1%86%D0%B5%D0%BF%D0%BE%D1%87%D0%BA%D0%B5)
  - [Параллельное выполнение промисов](#%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%D0%BE%D0%B2)
  - [Создание завершенных промисов](#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%D0%BE%D0%B2)
  - [Промисификация](#%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Промисы

## Определение

**Promise** или **промис** – особый объект, предназначенный для обозначения результата [асинхронной](async_basics.md) операции. Содержит свое состояние и позволяет добавить обработчики успешного или неуспешного завершения операции. 

## Состояния

* Pending – промис еще не отмечен выполненным, "операция в процессе"
* Fulfilled – промис отмечен выполненным успешно
* Rejected – промис отмечен выполненным с ошибкой

> Промис, состояние которого переведено из `pending` в любое другое, больше не может менять свое состояние. 

## Способ использования

* Код, который "планирует" делать что-то асинхронное, создает промис и передает его "ожидающему" (обычно внешнему для функции) коду
* Внешний код вешает обработчики на промис
* При завершении операций асинхронный код отмечает промис выполненным, вызываются обработчики

## Создание промиса

Promise создается с помощью конструктора `Promise`. Ему передается функция, которая и будет совершать асинхронные операции. Она будет вызвана автоматически, и в неё будет передано два аргумента: 

1. Функция, которую нужно вызвать, чтобы отметить промис выполненным успешно (обычно называют `resolve`)

2. Функция, которую нужно вызвать, чтобы отметить промис выполненным с ошибкой (обычно. называют `reject`)

   > Кстати, выброс [ошибки](errors.md) из промиса будет аналогичен вызову `reject`

```javascript
const promise = new Promise((resolve, reject) => {
  // Тут выполняются любые операции
  // Когда операции завершены, вызывается resolve или reject:
  readFile(file, (err, data) => {
    if (err) {
      reject(err);
    } else {
      resolve(data);
    }
  })
});
```

```javascript
function asyncSum(a, b) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(a + b);
    }, 5000);
  });
}

asyncSum(1, 3)
  .then(result => console.log(result));
```

## Добавление обработчиков

Когда промис создан, на него можно повесить обработчики, которые будут вызваны, когда промис выполнится. Для этого есть два метода:

* `then` – вызовет обработчик, когда промис завершится успешно
* `catch` – вызовет обработчик, когда промис завершится с ошибкой

Оба этих метода принимают функцию-обработчик:

```javascript
promise
  .then((data) => {
    console.log(data);
  })
  .catch((err) => {
    console.error(err);
  });
```

Функция из `then` будет вызвана с теми данными, которые будут переданы в `resolve`, а функция из `catch` – с данными из `reject`.

> Обработчики можно добавить и тогда, когда промис уже успел завершиться. Тогда обработчик будет вызван сразу. 

## Цепочки промисов

Для **последовательного** выполнения операций (например, когда после одного сетевого запроса нам нужно сделать другой) используют цепочки промисов. Для этого из функции, переданной в `then` одного промиса, возвращают новый промис , и тогда на него можно будет подписаться таким образом:

```javascript
makeRequest(urlOne) // вернет первый промис
  .then((data) => { // подписываемся на него
  	if (data.ok) {
  		return makeRequest(urlTwo) // возвращаем второй
  	}
  })
  .then((data) => { // подписываемся на второй
  	if (data.ok) {
  		return makeRequest(urlThree) // возвращаем третий
  	}
  })
  .then(() => console.log('Done.')); // подписываемся на третий
```

```javascript
makeAuthRequest()
  .then(makeMoneyTransferRequest)
  .then(makeNotificationRequest)
  .then(writeToLog)
  .then(makeLogoutRequest);
```

Таким образом запросы будут выполняться **последовательно**, то есть следующий будет начинаться только тогда, когда закончился предыдущий. 

### Что можно вернуть из `then`

* Промис, тогда функция из следующего `then` в цепочке будет вызвана, когда он выполнится
* Другое значение, тогда функция из следующего `then` будет вызвана сразу с этим значением

### Обработка ошибок в цепочке

Если один из промисов в цепочке завершится с ошибкой, обработана она будет ближайщим обработчиком `catch` в цепочке, при этом все `then` между текущим и ближайшим `catch` будут проигнорированы. То, что вернет `catch`, будет обработано так же, как значения, возвращаемые из `then` (после `catch` снова может идти `then`).

```javascript
doSomething()
  .then(doSomethingElse)
  .then(doSomethingElse2)
  .then(doSomethingElse3)
  .then(doSomethingElse4)
  .catch((error) => {...})
```

> Функция из `catch` будет вызвана при возникновении ошибки где-либо выше неё в цепочке.

## Параллельное выполнение промисов

Так как промисы предназначены для работы с асинхронными операциями, несколько одновременно созданных промисов будут работать параллельно (условно). Здесь речь пойдет о том, как получить результаты нескольких промисов, результаты которых нам нужны только тогда, когда они все закончат работу. 

Для таких ситуаций существует метод `Promise.all`. Он принимает массив или другое итерируемое (см [итераторы](iterators.md), [генераторы](generators.md)) значение и возвращает новый промис, который завершится в двух ситуациях:

* Успешно, если **все** переданные промисы завершились успешно. Результатом будет массив с результатами переданных промисов
* Не успешно, если **хотя бы один** из промисов завершится неуспешно

> Значения, переданные в `Promise.all` и не являющиеся промисами, будут преобразованы с помощью `Promise.resolve`.

```javascript
Promise.all([
  requestOne(), 
  requestTwo(), 
  requestThree()
]).then((results) => {
  const [resultOne, resultTwo, resultThree] = results;
});
```

Функция из `then` будет вызвана **только тогда**, когда все три промиса будут завершены успешно. В `results` будет массив, где будут находиться результаты промисов в соответствии с их порядком. 

## Создание завершенных промисов

В ситуациях, когда нам нужно сымитировать промис, завершившийся с каким-либо значением, можно использовать один из методов:

* `Promise.resolve` – создает промис в состоянии fulfilled со значением, переданным методу
* `Promise.reject` – создает промис, завершившийся в rejected со значением, переданным методу

> Например:
>
> ```javascript
> doSomething()
>   .then(() => {
>     	return Promise.reject();
>   })
>   .then(makeRequest)
>   .then(showPopup)
>   .catch(() => {...})
> ```
>
> После `return Promise.reject();` будет сразу вызвана функция из `catch`.

## Промисификация

Промисификацией называется подход, когда функции, работающие с асинхронностью с помощью колбеков, преобразовывают в работающие с промисами. 

Подход заключается в том, чтобы сделать новые функции, аналогичные по интерфейсу существующим, но возвращающим промис, завершающийся тогда, когда исходная функция вызывает колбек.

Например, представим функцию, работающую с колбеками и используемую так:

```javascript
makeRequest(url, data, (result) => {
  // обработка результата
});
```

Её можно "обернуть" в промис, сделав функцию, которую будет удобно использовать с остальными промисами:

```javascript
function makeRequestPromise(url, data) {
  return new Promise((resolve) => {
    makeRequest(url, data, resolve);
  });
}

makeRequestPromise('https://google.com', { search: 'котики' })
  .then(...)
```

Тогда `makeRequestPromise` можно будет использовать вместо `makeRequest` и пользоваться всеми возможностями, предоставляемыми промисами, например, работать с [асинхронными функциями](async_async_fn.md). 
