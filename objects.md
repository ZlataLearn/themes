<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
[Назад](README.md)<br />**Содержание**

- [Объекты](#%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B)
  - [Определение](#%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)
  - [Структура](#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0)
  - [Создание](#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5)
    - [Литерал объекта](#%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0)
      - [Пустой объект](#%D0%BF%D1%83%D1%81%D1%82%D0%BE%D0%B9-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82)
      - [Объект с заданными значениями свойств](#%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82-%D1%81-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2)
      - [Вычисляемые ключи свойств](#%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D1%8F%D0%B5%D0%BC%D1%8B%D0%B5-%D0%BA%D0%BB%D1%8E%D1%87%D0%B8-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2)
      - [Значения свойств из одноименных переменных](#%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2-%D0%B8%D0%B7-%D0%BE%D0%B4%D0%BD%D0%BE%D0%B8%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)
    - [Конструктор объекта](#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0)
  - [Изменение свойств](#%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2)
    - [Оператор `.`](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-)
    - [Оператор `[]`](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-)
    - [Метод `defineProperty`](#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4-defineproperty)
    - [Оператор `delete`](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-delete)
  - [Чтение свойств](#%D1%87%D1%82%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2)
    - [Операторы `.` и `[]`](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B--%D0%B8-)
    - [Опрератор `in`](#%D0%BE%D0%BF%D1%80%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-in)
    - [Цикл `for (… in …)`](#%D1%86%D0%B8%D0%BA%D0%BB-for--in-)
  - [Хранение по ссылке](#%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B5)
    - [Копирование объектов](#%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2)
    - [Сравнение объектов](#%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Объекты

## Определение

**Объекты** – значения, представляющие из себя "коллекцию" любых других данных. Объекты можно представить в виде ящика с подписанными папками, в которых что-то хранится. 

## Структура

Данные в объектах хранятся в парах ключ-значение.

* Ключ – идентификатор, указывающий на значение в объекте. Ключи могут быть только строками, все другие значения будут преобразованы в строковые.
* Значение – любые данные поддерживаемого [типа](types.md), ассоциированы с ключом.

## Создание

### Литерал объекта

Для описания объекта используется пара фигурных скобок (`{` и `}`), между ними опционально указываются пары ключ-значение через двоеточие (`:`), разделенные запятой.

> Ключ может быть любым строковым значением. Если название ключа соответствует правилам именования [переменных](variables.md), его можно указать без кавычек. Если название ключа представлено не строкой, оно будет [преобразовано](types.md) к строке. 

#### Пустой объект

```javascript
let object = {};
```

#### Объект с заданными значениями свойств

```javascript
let object = {
  key1: 'value1',
  key2: true,
  "some key 3": 'value3'
};
```

#### Вычисляемые ключи свойств

Если значение (название/идентификатор) ключа заранее неизвестно, например, зависит от значения переменной, его можно вычислить в момент создания объекта (для этого используют квадратные скобки (`[` и `]`)):

```javascript
let value = ...; // представим, что мы не знаем заранее, что в этой переменной
let object = {
  key1: 'value',
  [value]: 12345,
};
```

Здесь ключом для значения `12345` будет то, что хранится в переменной `value` на момент создания объекта. Например, если `value` равно `'ABC'`, то и ключом будет строка `'ABC'`.

#### Значения свойств из одноименных переменных

Если в объект записываются значения, хранящиеся в переменных, и имя переменной совпадает с именем ключа, запись можно сократить. 

Записи ниже будут эквивалентны:

```javascript
let name = 'John';
let lastName = 'Doe';
let object = {
  name: name,
  lastName: lastName,
};
```

```javascript
let name = 'John';
let lastName = 'Doe';
let object = {
  name,
  lastName,
};
```

### Конструктор объекта

Второй способ рассмотрен более подробно в [конструкторах](constructors.md) и заключается в использовании функций как конструкторов объектов. Самым базовым примером конструктора может быть конструктор `Object`:

```javascript
let object = new Object();
```

В таком случае функция `Object` *конструирует* новый объект и возвращает его. Работать с ним можно так же, как и с описанным с помощью литеральной нотации.

## Изменение свойств

Свойства уже созданного объекта можно менять или создавать новые.

### Оператор `.`

Оператор `.` позволяет *обратиться* к любому значению, которое хранится в объекте, по его ключу.

```javascript
let object = {
  name: 'John',
};
```

```javascript
object.name = 'Steve';
object.lastName = 'Foo';
// теперь object выглядит как { name: 'Steve', lastName: 'Foo' }
```

> Этот оператор можно использовать только с ключами, чье имя соответствует правилам именования идентификаторов (см [переменные](variables.md)).

### Оператор `[]`

Оператор `[]` позволяет обратиться к значениям вне зависимости от именования его ключа:

```javascript
object['name'] = 'Steve';
object['lastName'] = 'Foo';
```

```javascript
let nameKey = 'name';
let lastNameKey = 'lastName';
object[nameKey] = 'Steve';
object[lastNameKey] = 'Foo';
```

В `[]` можно использовать любые значения, но они будут преобразованы к `string`.

### Метод `defineProperty`

Свойство объекта можно создать или изменить с помощью метода объекта `Object` `defineProperty`. Отличием от создания через `.` или `[]` является то, что такие свойства можно настроить:

```javascript
Object.defineProperty(object, 'newKey', {
  // свойства дескриптора
});
```

`Object.defineProperty` принимает три аргумента:

1. Объект, в котором нужно создать или изменить свойство
2. Ключ, по которому создается или меняется свойство
3. Дескриптор – простой объект, в котором можно указать то, как новое свойство должно работать:
   - `configurable` (`true` / `false`) – можно ли изменять дескриптор в будущем
   - `enumerable` (`true` / `false`) – можно ли увидеть это свойство через [цикл](loops.md) `for (... in ...)`
   - `value` – то, какое значение будет записано в свойстве
   - `writable` (`true` / `false`) – можно ли менять это значение
   - `get` (функция) – *геттер*, будет вызван при каждом чтении свойства объекта; результат работы будет считан как значение свойства
   - `set` (функция) – *сеттер*, будет вызван при записи в свойство значений; аргументом получит новое значение свойства

> Дескриптор может содержать либо ключи `value` и `writable`, либо `get` и `set`, но не одновременно.

> Геттер и сеттер могут полностью менять работу свойства. Например, сеттер может как угодно преобразовывать данные перед записью, или вообще игнорировать запись, а геттер может отдавать данные, собираемые не из значения свойства, а из других источников

> Например:
>
> ```javascript
> let realCounter = 0;
> Object.defineProperty(object, 'counter', {
>     get: function () { // или сокращенно get() {, что было бы эквивалентно
>       return realCounter++;
>     }
> });
> ```
>
> Так при чтении `object.counter` мы всегда будем получать значение, на `1` большее предыдущего:
>
> ```javascript
> object.counter; // === 0
> object.counter; // === 1
> object.counter; // === 2
> ```
>
> При этом *на самом деле* значение будет храниться не в `counter`, а в `realCounter`, и будет увеличиваться при каждом вызове геттера `counter` .

### Оператор `delete`

Оператор `delete` используется для удаления существующего свойства объекта:

```javascript
delete object.name;
delete object['lastName'];
```

## Чтение свойств

### Операторы `.` и `[]`

Операторы `.` и `[]` для чтения работают так же, как и для записи свойств:

```javascript
console.log(object.some);
let newValue = object['field'];
```

### Опрератор `in`

Опрератор `in` позволяет проверить, есть ли свойство с каким-либо ключом в объекте:

```javascript
'name' in object // вернет true, если name есть и false, если нет
```

### Цикл `for (… in …)`

[Цикл](loops.md) `for (… in …)` позволяет перебирать ключи объекта:

```javascript
for (let key in object) {
  // каждый раз key будет равен следующему ключу
}
```

## Хранение по ссылке

В то время, когда для других [типов](types.md) (их называют примитивами) в переменных хранится **значение**, для объектов хранится **указание на объект**, которых фактически хранится в памяти независимо от переменной. 

Поэтому при присвоении значения из одной переменной в другую, копируется это указание (*ссылка*), и не копируются данные из объекта, а новая переменная начинает *указывать* на тот же объект.

> Например,
>
> ```javascript
> let object = { name: 'John' };
> let newObject = object;
> // newObject.name === 'John'
> newObject.lastName = 'Doe';
> // object  хранит { name: 'John', lastName: 'Doe' }
> ```
>
> Здесь и `object` и `newObject` указывают на один и тот же объект, который был создан на первой строке

### Копирование объектов

Есть два варианта копирования объектов:

* Поверхностное копирование
* Глубокое копирование

Для **поверхностного** копирования обычно испольуют оператор "[spread](spread_rest.md)" (многоточие, `…`):

```javascript
let object = { a: 1, b: 2 };
let newObject = {
	...object,
};
// newObject  хранит { a: 1, b: 2 }
```

Минусом поверхностного копирования является то, что если одним (или более) из значений свойств будет еще один объект, то в новом объекте окажется та же ссылка на него, как и при обычном присваивании.

Для **глубокого** копирования нет встроенных инструментов в JavaScript. Обычно оно реализуется (самостоятельно или с использованием библиотек) рекурсивным перебором всех свойств объекта с проверкой на то, объект ли хранится в свойстве (и если да, копированием и его).

### Сравнение объектов

Хранение по ссылке влияет и на сравнение объектов друг с другом. 

Сравнение **любых** двух разных объектов покажет, что они не равны друг другу, поскольку сравниваются ссылки на них:

```javascript
let o1 = { a: 'b' };
let o2 = { a: 'b' };

o1 === o2 // false
{} === {} // false
```

Также сравнение объекта самого с собой (даже если ссылка на него хранится в разных переменных) вернет `true`:

```javascript
let o1 = { a: 'b' };
let o2 = o1;

o1 === o2 // true
```

