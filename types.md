<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Содержание**

- [Типы данных](#%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
  - [Определение](#%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)
  - [Классификация](#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F)
  - [Преобразование типов](#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2)
      - [Явное и неявное](#%D1%8F%D0%B2%D0%BD%D0%BE%D0%B5-%D0%B8-%D0%BD%D0%B5%D1%8F%D0%B2%D0%BD%D0%BE%D0%B5)
      - [Таблицы преобразований](#%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9)
        - [В числа](#%D0%B2-%D1%87%D0%B8%D1%81%D0%BB%D0%B0)
        - [В логические значения](#%D0%B2-%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)
        - [В строки](#%D0%B2-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Типы данных

## Определение

В зависимости от **типа данных** над значениями возможны различные операции (как, например, сложение над числами или измерение длины у строк).  

## Классификация

В JavaScript есть семь типов данных: 

- `null`
- `undefined`
- `boolean`
- `string`
- `number`
- `object`
- `symbol`

| Тип         | Описание                                                     |
| ----------- | ------------------------------------------------------------ |
| `null`      | Тип с одним возможным значением (`null`). <br />Обычно означает "ничего". Например, если программа получает откуда-то данные, то `null` может означать "запрос прошел успешно, но данных нет". |
| `undefined` | Так же, как и `null`, имеет только одно значение – `undefined`. <br />Означает переменную, не получившую никакого значение. Например, после вызова `const foo` в переменной `foo` будет храниться `undefined` |
| `boolean`   | Имеет два значения – `true` и `false`<br />Означает логическое "да" или "нет", например, переменная `userIsAdmin`, равная `true` означала бы, что пользователь является администратором (чего-либо, зависит от программы) |
| `string`    | Содержит любое строковое значение<br />Строки могут быть описаны с помощью кавычек (варианты: `"` или `'` ; разница в том, что внутри строки, описанной в двойных кавычках, вы можете использовать одинарные как часть строки, а в одинарных – двойные: `"Название: 'JavaScript'"` или `'Название: "JavaScript"'`)<br />Доп: [шаблонные строки](template_strings.md) |
| `number`    | Содержит числовые значения, например, `-10` или `12.31`      |
| `object`    | В отличие от остальных типов значения типа `object` содержат в себе дополнительные значения любых типов. Например, объект `user` может содержать поля `name` и `lastname` типа `string` и поле `age` типа `number` <br />Подробнее об объектах: [объекты](objects.md) |
| `symbol`    | Тип, которые содержит всегда уникальные значения. Вызов функции `Symbol()` всегда приведет к созданию нового значения, которое не будет совпадать с предыдущими.<br />Значения, полученные от `Symbol()` не предназначены для чтения людьми, их вывод покажет просто `"Symbol()"`, но для удобства можно передать в функцию название, тогда оно будет отображаться при выводе (`Symbol("key")` создаст уникальное значение, "помеченное" названием "key").<br />Один `symbol` никогда не равен другому. |

## Преобразование типов

Когда мы выполняем операции над данными разных типов, они должны преобразоваться в соответствующие значения одного, общего для всех, типа. 

#### Явное и неявное

Такое преобразование бывает двух видов:

* Явное, когда мы сами указываем, к чему привести значение 
* Неявное, когда это делает автоматически язык

Для явного преобразования есть соответствующие методы и функции. Например, превратить что-либо в число можно, вызвав функцию `Number` и передав ей значение (`Number('123')` или `Number(null)`). 

Неявное приведение выбирается языком в соответствии с операцией, происходящей над значениями:

* Математические операции вызывают приведение всех значений к числам. 
* Логические – к типу `boolean`
* Вывод (например, `alert(1)`) приводит к приведению к строковому типу

> **Стоит отметить**, что операция `+` может означать как сложение чисел (если ни одно из значений не является строкой), так и операцию соединения строк (если хотя бы одно из значений является строкой).
>
> Например, результатом вычисления `10 + "20"` будет строка `"1020"`, потому что `+` здесь – не сложение, а конкатенация (соединение) строк.
>
> В другом случае, если мы будем вычислять `10 + null`, плюс останется операцией математического сложения, и все не-числа будут преобразованы к числам. 
>
> Бывают и смешанные ситуации: `1 + 10 + 1 + "2"`. Здесь первые два плюса математические, а последний – соединение строк, поэтому в результате мы получим `"122"`, как `12 + "2"`. 

#### Таблицы преобразований

##### В числа

| Значение       | Становится                                                   |
| :------------- | :----------------------------------------------------------- |
| `undefined`    | `NaN` (особое значение типа `number`, не-число)              |
| `null`         | `0`                                                          |
| `true / false` | `1 / 0`                                                      |
| `string`       | Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то `0`, иначе из непустой строки «считывается» число. При ошибке результат `NaN`. |

##### В логические значения

| Значение                              | Становится |
| ------------------------------------- | ---------- |
| `0`, `""`, `null`, `undefined`, `NaN` | `false`    |
| Все остальное                         | `true`     |

##### В строки

Примитивные типы (все, кроме объектов) приводятся интуитивно – `123` в `"123"`, `true` в `"true"` и т.д. 

Если у объекта есть метод `toString`, он вызывается и результатом приведения будет то, что вернет этот метод. В противном случае результатом будет строка `"[object Object]"`, где `Object` соответствует классу объекта. (см [Объекты](objects.md) и [Классы](classes.md)). 

