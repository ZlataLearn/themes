# Базы данных и SQL

## Определения

**База данных** – организованная совокупность данных различных типов.

**Система управления базой данных (СУБД)** – набор программ, позволяющих работать с базой данных. 

**SQL** – распространенный язык запросов к базам данных. Существуют различные диалекты, отличающиеся наличием расширенных возможностей.

## Реляционные базы данных

**Реляционными** называют базы, основанные на модели, включающей в себя связи между различными сущностями в базе. Такие базы можно представить в виде набора таблиц.

### Таблицы

Давайте рассмотрим пример. Допустим, необходима база данных для хранения информации о книгах в библиотеке. 

Очевидно, нам нужна таблица `books`. Что мы знаем о книгах? У них есть название, какой-то размер, и, например, год выпуска.

#### `books`

| id   | name                                        | size | year |
| ---- | ------------------------------------------- | ---- | ---- |
| 1    | Приключения зубчика                         | 475  | 2019 |
| 2    | Зубки без зубика                            | 500  | 2020 |
| 3    | Квадратность или как быть звуком будильника | 157  | 1995 |
| 4    | Как может летать небо?                      | 200  | 2010 |

Еще у книг есть авторы:

#### `authors`

| id   | name            |
| ---- | --------------- |
| 1    | Злата           |
| 2    | Леша            |
| 3    | Анонимный автор |

### Связи между таблицами

Одна из основных концепций в реляционных БД – связи. Связь означает, что какие-то записи (строки) одной таблицы как-то относятся к записям в других таблицах. Например, для книг, это связь автор-книга.

Связи бывают трех типов:

- Один к одному
- Один ко многим
- Многие ко многим

#### Один к одному

Такая связь означает, что для записи в таблице А есть только одна запись в таблице Б. Например, это может быть книга и её цена в таблице с ценами. Для каждой книги есть одна запись в ценах, а для каждой цены есть одна книга.

Обычно это аналогично добавлению нового столбца в таблицу А, но не перегружает информацией эту таблицу и позволяет обращаться за ней тогда, когда она нужна.

#### Один ко многим

Это самый частый случай. Для записи в таблице А есть любое количество записей в таблице Б. Например, у каждого автора может быть сколько угодно книг. Но у каждой книги только один автор (это упрощение для наглядности).

Обычно, такие связи реализуются добавлением в таблицу Б столбца с id записи из таблицы А:

| id   | name                                        | size | year | author_id |
| ---- | ------------------------------------------- | ---- | ---- | --------- |
| 1    | Приключения зубчика                         | 475  | 2019 | 1         |
| 2    | Зубки без зубика                            | 500  | 2020 | 3         |
| 3    | Квадратность или как быть звуком будильника | 157  | 1995 | 2         |
| 4    | Как может летать небо?                      | 200  | 2010 | 3         |

#### Многие ко многим

Этот случай требует промежуточной таблицы связей. Примером такой связи может быть история того, кто из посетителей библиотеки читал какие книги. Как один человек мог читать разные книги, так и одну книгу могли читать разные люди:

##### `readers`

| id   | name  |
| ---- | ----- |
| 1    | Леша  |
| 2    | Злата |

##### `readers_books`

| reader_id | book_id |
| --------- | ------- |
| 1         | 1       |
| 1         | 3       |
| 2         | 3       |
| 2         | 2       |

### Индексы

Когда в базе накапливается достаточно много данных, проявляется необходимость думать о производительности. Например, если нам нужно часто получать из таблицы `books` все книги за какой-то год, СУБД придется каждый раз полностью читать все записи и проверять – подходит она или нет. Это медленно.

Для решения этой проблемы существуют **индексы** (упрощенно – отсортированные списки значений из таблицы, которые мы индексируем) – они позволяют не искать по всей таблице, а с помощью бинарного поиска быстро находить нужные записи.

Помимо этого у индексов есть и минус – каждое изменение индексируемых данных таблицы заставляет СУБД пересчитывать индекс, а это тратит время. Поэтому добавлять индексы нужно только на то, по чему производится поиск, и для чего нужна скорость.

## SQL

Поскольку я, честно говоря, не слишком много знаю про SQL, я остановлюсь на конкретных вариантах запросов.

### Чтение данных, `SELECT`

```sql
SELECT <список полей> FROM <название таблицы> [WHERE <условие>] [ORDER BY <сортировка>] [LIMIT <лимит>]
```

#### Список полей

Это может быть как разделенное запятой перечисление полей, так и `*` для выбора всех. Например, `SELECT id, name …` или `SELECT * …`

#### Название таблицы

Указывает на то, откуда будут браться данные.

`SELECT id, name FROM books ...`

#### Условие

Логическое выражение, результат которого указывает на то, будет ли добавлена запись в результат. Может включать операторы `AND`, `NOT` и `OR`, а также скобки для группировки отдельных выражений.

Выражения могут быть такими:

- `=`, `>`, `<` и т.д. – `WHERE id = 7 OR size > 30`
- `IN` – `WHERE id IN (1, 3, 7)`
- `LIKE` – `WHERE name LIKE '%зуб%'`. `%` означает любой набор символов, а `_` – один любой символ
- `BETWEEN … AND …` – `WHERE size BETWEEN 100 AND 400`

#### Сортировка

Задает список правил сортировки. Все записи, одинаковые по первому правилу, сортируются между собой по второму и так далее. 

`ORDER BY size ASC, name DECS`

`ASC` – сортировка по возрастанию

`DESC` – сортировка по убыванию

#### Лимит

Ограничивает размер результата. Принимает либо одно значение, либо два:

- Одно значение – максимальное количество строк
- Два значения – первое указывает сдвиг от начала, а второе – максимальное количество строк

Например, `LIMIT 10, 100` выведет 100 записей, начиная с 11-й.

#### Пример запроса

```sql
SELECT
	id, name
FROM
	books
WHERE
	size > 100
ORDER BY id DESC
LIMIT 50
```

### Добавление данных, `INSERT`

```sql
INSERT INTO <название таблицы> (<список полей>) VALUES (<список значений>)
```

Список полей – разделенные запятой названия полей таблицы. Если добавляются данные во все поля, список можно опустить. Список значений содержит значения в соответствующем порядке.

```sql
INSERT INTO books (name, size) VALUES ('Погода на завтра', 1)
```

### Удаление данных, `DELETE`

Удаляет все записи, подходящие под условие. 

```sql
DELETE FROM <название таблицы> WHERE <условие>
```

```sql
DELETE FROM books WHERE author_id = 7
```

### Обновление данных, `UPDATE`

```sql
UPDATE <название таблицы> SET <список изменений> WHERE <условие>
```

Список изменений в формате `column1 = value1, column2 = value2, ...`

Например:

```sql
UPDATE books SET size = 100 WHERE id = 2
```

### Подзапросы

Внутри одних запросов можно выполнять другие, используя их результаты, например, в условиях. Например, для запроса всех книг от авторов, чье имя начинается с "Ъ", можно написать такой запрос:

```sql
SELECT * FROM books
WHERE author_id IN (SELECT id FROM authors WHERE name LIKE 'Ъ%')
```

## TODO:

- `JOIN`
- `GROUP BY`
- `COUNT`, `MAX`, `MIN`, `SUM`, `AVG`

