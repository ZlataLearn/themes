# Асинхронность

## Определение

**Асинхронными** называют операции, которые выполняются не вместе с остальным *синхронным* кодом, а откладываются до его завершения или до завершения каких-либо задач (например, сетевого запроса).

Например, представим список задач, который описан в коде примерно так:

1. Взять данные из формы
2. Отправить запрос на сервер
3. Обработать ответ от сервера
4. Сохранить данные в лог

Скорее всего, асинхронной (отложенной) будет операция **3**, поэтому код выполнится в таком порядке:

- Взять данные из формы
- Отправить запрос на сервер
- Сохранить данные в лог

...

- Обработать ответ от сервера

### Основные ситуации

Чаще всего асинхронными бывают следующие операции:

* Сетевые запросы
* Чтение/запись файлов
* Запросы к базе данных
* Намеренно отложенные во времени операции
* Инициализация библиотек

## Способы обработки асинхронности

* Функции обратного вызова (колбек, callback) – будут рассмотрены здесь
* Промисы (Promise, обещание) – см [промисы](async_promises.md)
* Асинхронные функции – см ([асинхронные функции](async_async_fn.md))

## Функции обратного вызова

Функциями обратного вызова называют функции, передаваемые в качестве аргумента куда-либо, и вызываемые тогда, когда асинхронная операция завершена. 

Например, так мог бы выглядеть сетевой запрос:

```javascript
console.log("Отправляю запрос");

makeRequest(url, (err, data) => {
  console.log("Обрабатываю ответ");
});

console.log("Запрос отправлен");
```

Здесь порядок вывода сообщений в консоль будет таким:

```
1. Отправляю запрос
2. Запрос отправлен
3. Обрабатываю ответ
```

### `setTimeout` и `setInterval`

Яркими примерами асинхронности могут быть функции `setTimeout` и `setInterval`. Они не являются частью языка, но реализованы в большинстве сред. 

Для чего они нужны:

* `setTimeout` откладывает выполнение функции на определенное время
* `setInterval` выполняет функции бесконечно раз в определенное время

Обе функции первым аргументом принимают колбек, а вторым – время в миллисекундах. Дополнительные аргументы попадут в колбек при вызове.

> ```javascript
> setTimeout((a, b, c) => {
>   // делаем что-то
> }, 2000, 1, 2, 3);
> ```
>
> Через две секунды после этой строчки (`2000` миллисекунд) вызовется функция `(a, b, c) => …` с аргументами `1`, `2`, `3`.

Обе функции возвращают идентификатор, который можно использовать, передав в другие функции, необходимые, чтобы отменить запланированные ими операции:

* `clearTimeout` для `setTimeout`
* `clearInterval` для `setInterval`

> ```javascript
> const t = setTimeout(...);
> clearTimeout(t);
> ```

